# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import connection_pb2 as connection__pb2

# for service
from app import db
from datetime import datetime, timedelta
from typing import Dict, List
from sqlalchemy.sql import text
from app.udaconnect.models import Connection, Location, Person
from app.udaconnect.schemas import ConnectionSchema, LocationSchema, PersonSchema


class ConnectionServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetConnections = channel.unary_unary(
                '/ConnectionService/GetConnections',
                request_serializer=connection__pb2.ConnectionMessage.SerializeToString,
                response_deserializer=connection__pb2.AllConnections.FromString,
                )


class ConnectionServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def GetConnections(self, request, context):
        """Missing associated documentation comment in .proto file."""
        # context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        # context.set_details('Method not implemented!')
        # raise NotImplementedError('Method not implemented!')
        locations: List = db.session.query(Location).filter(
            Location.person_id == request["person_id"]
        ).filter(Location.creation_time < request["end_date"]).filter(
            Location.creation_time >= request["start_date"]
        ).all()

        # Cache all users in memory for quick lookup
        person_map: Dict[str, Person] = {person.id: person for person in db.session.query(Person).all()}

        # Prepare arguments for queries
        data = []
        for location in locations:
            data.append(
                {
                    "person_id": request["person_id"],
                    "longitude": location.longitude,
                    "latitude": location.latitude,
                    "meters": request["distance"],
                    "start_date": request["start_date"].strftime("%Y-%m-%d"),
                    "end_date": (request["end_date"] + timedelta(days=1)).strftime("%Y-%m-%d"),
                }
            )

        query = text(
            """
        SELECT  person_id, id, ST_X(coordinate), ST_Y(coordinate), creation_time
        FROM    location
        WHERE   ST_DWithin(coordinate::geography,ST_SetSRID(ST_MakePoint(:latitude,:longitude),4326)::geography, :meters)
        AND     person_id != :person_id
        AND     TO_DATE(:start_date, 'YYYY-MM-DD') <= creation_time
        AND     TO_DATE(:end_date, 'YYYY-MM-DD') > creation_time;
        """
        )
        result: List[connection__pb2.ConnectionResult] = []
        for line in tuple(data):
            for (
                exposed_person_id,
                location_id,
                exposed_lat,
                exposed_long,
                exposed_time,
            ) in db.engine.execute(query, **line):
                location = connection__pb2.LocationType(
                    id=location_id,
                    person_id=exposed_person_id,
                    creation_time=exposed_time,
                )
                location.set_wkt_with_coords(exposed_lat, exposed_long)

                result.append(
                    Connection(
                        person=person_map[exposed_person_id], location=location,
                    )
                )
        return result


def add_ConnectionServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GetConnections': grpc.unary_unary_rpc_method_handler(
                    servicer.GetConnections,
                    request_deserializer=connection__pb2.ConnectionMessage.FromString,
                    response_serializer=connection__pb2.AllConnections.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ConnectionService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class ConnectionService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def GetConnections(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ConnectionService/GetConnections',
            connection__pb2.ConnectionMessage.SerializeToString,
            connection__pb2.AllConnections.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
